        .ABSOLUTE
        .PROC   IDECTL

LISTINC .EQU    0
        .INCLUDE ASMINC.TEXT

;;;        DEF_MPU                 ; DEFINE MPU SYMBOLS
        DEF_CH                  DEFINE CHARACTER SYMBOLS



;**    VERSION   A1
VERSION  .EQU	"A3"


;**     CHANGE HISTORY
;
;

        .PAGE
;*        ASSEMBLY PARAMETERS AND CONFIGURATION INFO
;
;
FALSE   .EQU    0
TRUE    .EQU    ~FALSE

DEBUG	.EQU	TRUE

PROMORG	.EQU	0800H		; OUR ORIGIN (PROM SOCKET 1)
PROMSIZE .EQU	0800H		; SIZE OF PROM WE NEED TO FIT IN
KEY_TBL .EQU    0C00H     	; WHERE MONITOR EXPECTS KEYBOARD TABLE

; ??  TEMPORARY
BUF	.EQU	07002H
BUFFER	.EQU	07020H


;       HARDWARE DEFINITIONS
;
;  I/O PORTS
IDEPTA		.EQU    30H	;LOWER 8 BITS OF IDE INTERFACE (8255)
IDEPTB		.EQU    31H	;UPPER 8 BITS OF IDE INTERFACE
IDEPTC		.EQU    32H	;CONTROL LINES FOR IDE INTERFACE
IDEPTCTRL	.EQU    33H	;8255 CONFIGURATION PORT
IDEDRIVE        .EQU    34H	;BIT 0 = 0 DRIVE A, =1 DRIVE B

;  8255 CONTROL REGISTER VALUES
READCFG8255     .EQU    92H    ;SET 8255 IDEPTC TO OUTPUT, IDEPTA/B INPUT
WRITECFG8255    .EQU    80H    ;SET ALL THREE 8255 PORTS TO OUTPUT MODE

;  IDE CONTROL LINES FOR USE WITH IDEPTC.
IDEA0LINE       .EQU    01H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA1LINE       .EQU    02H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA2LINE       .EQU    04H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDECS0LINE      .EQU    08H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDECS1LINE      .EQU    10H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDEWRLINE       .EQU    20H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERDLINE       .EQU    40H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERSTLINE      .EQU    80H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE


;  SYMBOLIC CONSTANTS FOR THE IDE DRIVE REGISTERS, WHICH MAKES THE
;  CODE MORE READABLE THAN ALWAYS SPECIFYING THE ADDRESS BITS
REGDATA         .EQU    IDECS0LINE
REGERR          .EQU    IDECS0LINE + IDEA0LINE
REGSECCNT       .EQU    IDECS0LINE + IDEA1LINE
REGSECTOR       .EQU    IDECS0LINE + IDEA1LINE + IDEA0LINE
REGCYLLSB	.EQU    IDECS0LINE + IDEA2LINE
REGCYLMSB	.EQU    IDECS0LINE + IDEA2LINE + IDEA0LINE
REGSHD          .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE              ;(0EH)
REGCOMMAND      .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE  ;(0FH)
REGSTATUS       .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
REGCONTROL      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE
REGASTATUS      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE


;  IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
CMDRECAL	.EQU    10H
CMDREAD		.EQU    20H
CMDWRITE	.EQU    30H
CMDINIT		.EQU    91H
CMDID		.EQU    0ECH
CMDSPINDOWN 	.EQU    0E0H
CMDSPINUP	.EQU    0E1H

CMDFLUSH	.EQU	0EAH			; FLUSH CACHE


; IDE STATUS REGISTER:
;  BIT 7: BUSY	1=BUSY, 0=NOT BUSY
;  BIT 6: READY 1=READY FOR COMMAND, 0=NOT READY YET
;  BIT 5: DF	1=FAULT OCCURED INSIDE DRIVE
;  BIT 4: DSC	1=SEEK COMPLETE
;  BIT 3: DRQ	1=DATA REQUEST READY, 0=NOT READY TO XFER YET
;  BIT 2: CORR	1=CORRECTABLE ERROR OCCURED
;  BIT 1: IDX	VENDOR SPECIFIC
;  BIT 0: ERR	1=ERROR OCCURED

	.PAGE
	.MACRO PROGRESS
	LD	A,%1
	CALL	SHOWPROG
	.ENDM

	.ORG	PROMORG
ENTRY
	LD	HL,HELLOMSG	; ANNOUNCE WE GOT THIS FAR
	CALL	TXTOUT

	CALL	IDEINIT		; INITIALIZE DRIVE

	LD	HL,INITMSG	; "DRIVE INITIALIZED."
	CALL	TXTOUT

	LD	HL,0000H	; WRITE OUT THE START OF PROM 0
	LD	(BUF),HL
	CALL	WRITESECTOR
	JR	C,$20

	LD	HL,WRTMSG	; "ONE SECTOR WRITTEN"
	CALL	TXTOUT

	LD	HL,BUFFER	; READ INTO RAM
	LD	(BUF),HL
	CALL	READSECTOR
	JR	C,$20

	CALL	SHOWERRORS

	LD	HL,RDMSG	; "READ DATA ="
	CALL	TXTOUT
	LD	A,(BUFFER)
	CALL	HEXOUT

$1	JP 	$1

$20	LD	HL,ABTMSG	; "TEST ABORTED"
	CALL	TXTOUT
	JR	$1
	.PAGE

;*        CONSOLE MESSAGES
;
;
HELLOMSG .ASCII "IDE DRIVER TEST "
        .BYTE   VERSION/100H
        .BYTE   VERSION&0FFH
        .BYTE	CH_CR
        .BYTE	CH_LF
        .BYTE	CH_ETX

INITMSG	.ASCII	"DRIVE INITIALIZED."
	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX

STATMSG	.ASCII	"STATUS = "
	.BYTE	CH_ETX

ERRMSG	.ASCII	", ERR = "
	.BYTE	CH_ETX

WRTMSG	.ASCII	"ONE SECTOR WRITTEN."
	.BYTE	CH_ETX

ABTMSG	.ASCII	"TEST ABORTED."
	.BYTE	CH_ETX

RDMSG	.ASCII	"READ DATA = "
	.BYTE	CH_ETX

CRLF	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX

;*        PROGRAM VARIABLES
;
;
;DLYCNT 	.BLOCK  1               ; SCRATCH FOR DELAY SUBROUTINE
DLYCNT	.EQU	07000H
;TRK	.BLOCK  2               ; DISK ADDRESS - TRACK PART
;SEC	.BLOCK  1               ; DISK ADDRESS - SECTOR PART
;BUF	.BLOCK	2		; BUFFER ADDRESS
TRK	.WORD  0               ; DISK ADDRESS - TRACK PART
SEC	.BYTE  0               ; DISK ADDRESS - SECTOR PART
;BUF	.WORD	0000H		; BUFFER ADDRESS
	.PAGE

;*        SUBROUTINE IDEINIT
;
;  INITIALIZE 8255 PIO CHIP AND DRIVE,  AND THEN CHECK DRIVE STATUS.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CHANGED
;
IDEINIT
	LD	A,READCFG8255	;CONFIG 8255 CHIP (10010010B), READ MODE ON RETURN
	OUT	(IDEPTCTRL),A	;CONFIG 8255 CHIP, READ MODE

				;HARD RESET THE DISK DRIVE
				;FOR SOME REASON SOME CF CARDS NEED TO THE RESET LINE
				;PULSED VERY CAREFULLY. YOU MAY NEED TO PLAY AROUND
	LD	A,IDERSTLINE	;WITH THE PULSE LENGTH. SYMPTOMS ARE: INCORRECT DATA COMMING
	OUT	(IDEPTC),A	;BACK FROM A SECTOR READ (OFTEN DUE TO THE WRONG SECTOR BEING READ)
				;I HAVE A (NEGATIVE)PULSE OF 2.7USEC. (10MZ Z80, TWO IO WAIT STATES).
	LD	B,40H		;WHICH SEEM TO WORK FOR THE 5 DIFFERENT CF CARDS I HAVE.
$1	DEC	B		; JWD - SPEC SAYS 25 USEC MINIMUM!!!
	JR	NZ,$1		;DELAY (RESET PULSE WIDTH)

	XOR	A
	OUT	(IDEPTC),A	;NO IDE CONTROL LINES ASSERTED (JUST BIT 7 OF PORT C)
	CALL	DELAY32

	LD	D,11100000B	;DATA FOR IDE SDH REG (512BYTES, LBA MODE,SINGLE DRIVE,HEAD 0000)
				;FOR TRK,SEC,HEAD (NON LBA) USE 10100000
	LD	E,REGSHD	;00001110,(0EH) FOR CS0,A2,A1,
	CALL	IDEWR8D		;WRITE BYTE TO SELECT THE MASTER DEVICE
;
;  WAIT FOR DRIVE NOT BUSY, AND THE READY BIT SET.
;  THE BOARD DESIGNER'S CODE HAD AN EXTRA-LONG WAIT TIME HERE, TO HANDLE HDS SPINNING UP.
;  WE DON'T WORRY ABOUT THAT, TO SAVE CODE SPACE.
;
	CALL	IDEWAITNOTBUSY	; WAIT FOR DRIVE NOT BUSY (AND READY)
	RET	NC

	JP	SHOWERRORS	; REPORT AN ERROR



	.PAGE

;*        SUBROUTINE READSECTOR
;
;  READ A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA
;
;         ENTRY -
;
;         EXIT -
;                 CARRY FLAG SET ON ERROR.
;
				;Z ON SUCCESS, NZ CALL ERROR ROUTINE IF PROBLEM
READSECTOR
	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE
				;WILL GET STUCK ON BAD SECTOR
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS READY
	JR	C,GOSHOWERRORS	;RETURNED WITH NZ SET IF ERROR

	LD	D,CMDREAD	; ISSUE IDE READ COMMAND
	LD	E,REGCOMMAND
	CALL	IDEWR8D		;SEND SEC READ COMMAND TO DRIVE.

	CALL	IDEWAITDRQ	;WAIT UNTIL DRIVE READY TO DELIVER DATA
	JR	C,GOSHOWERRORS

	LD  	HL,(BUF)	;BUFFER ADDRESS
	LD	B,0		;READ 512 BYTES TO [HL] (256X2 BYTES)

$1	LD	A,REGDATA	;DATA REGISTER ADDRESS, NO READ LINE
	OUT	(IDEPTC),A

	OR	IDERDLINE	;08H+40H, ASSERT RD LINE
	OUT	(IDEPTC),A

	IN	A,(IDEPTA)	;READ THE LOWER BYTE FIRST
	LD	(HL),A
	INC	HL
	IN	A,(IDEPTB)	;THEN READ THE UPPER BYTE
	LD	(HL),A
	INC	HL

	DJNZ	$1

	LD	A,REGDATA	;DEASSERT RD LINE
	OUT	(IDEPTC),A

	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOSHOWERRORS

	LD	E,REGSTATUS
	CALL	IDERD8D
	LD	A,D
	AND	1H
	CALL	NZ,SHOWERRORS	;IF ERROR DISPLAY STATUS

	AND	A		; CLEAR CARRY FLAG
	RET

GOSHOWERRORS
	JP	SHOWERRORS
	.PAGE

;*        SUBROUTINE WRITESECTOR
;
;  WRITE A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA
;
;         ENTRY -
;
;         EXIT -
;                 CARRY FLAG SET ON ERROR.
;
WRITESECTOR
	PROGRESS	"A"
	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE
				;WILL GET STUCK ON BAD SECTOR
	PROGRESS	"B"
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOSHOWERRORS

	PROGRESS	"C"
	LD	D,CMDWRITE
	LD	E,REGCOMMAND
	CALL	IDEWR8D		;TELL DRIVE TO WRITE A SECTOR

	PROGRESS	"D"
	CALL	IDEWAITDRQ	;WAIT UNIT IT WANTS THE DATA
	JR	C,GOSHOWERRORS

	PROGRESS	"E"
	LD  	HL,(BUF)	;BUFFER ADDRESS
	LD	B,0		;256X2 BYTES

	LD	A,WRITECFG8255
	OUT	(IDEPTCTRL),A

$10	LD	A,(HL)
	INC	HL
	OUT	(IDEPTA),A	;WRITE THE LOWER BYTE FIRST
	LD	A,(HL)
	INC	HL
	OUT	(IDEPTB),A	;THEN HIGH BYTE ON B
	LD	A,REGDATA
	PUSH	AF
	OUT	(IDEPTC),A	;SEND WRITE COMMAND
	OR	IDEWRLINE	;SEND WR PULSE
	OUT	(IDEPTC),A
	POP	AF
	OUT	(IDEPTC),A
	DJNZ	$10

	PROGRESS	"F"
	LD	A,READCFG8255	;SET 8255 BACK TO READ MODE
	OUT	(IDEPTCTRL),A

	PROGRESS	"G"
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOBSHOWERRORS

	LD	E,REGSTATUS
	CALL	IDERD8D
	LD	A,D
	AND	1H
	CALL	NZ,SHOWERRORS	;IF ERROR DISPLAY STATUS

	AND	A		; CLEAR CARRY FLAG
	RET

GOBSHOWERRORS
	JP	SHOWERRORS
	.PAGE

;*        SUBROUTINE WRLBA
;
;  WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
;
;         ENTRY -
;
;         EXIT -
;
WRLBA
				;NOTE WE DO NOT NEED TO SET THE UPPER NIBBLE OF THE LBA
				;IT WILL ALWAYS BE 0 FOR THESE SMALL DRIVES
	LD	A,(SEC)		;LBA MODE LOW SECTORS GO DIRECTLY
	LD	D,A
	LD	E,REGSECTOR	;SEND INFO TO DRIVE
	CALL	IDEWR8D

	LD	HL,(TRK)
	LD	D,L		;SEND LOW TRK#
	LD	E,REGCYLLSB
	CALL	IDEWR8D

	LD	D,H		;SEND HIGH TRK#
	LD	E,REGCYLMSB
	CALL	IDEWR8D

	LD	D,1		;FOR NOW, ONE SECTOR AT A TIME
	LD	E,REGSECCNT
	CALL	IDEWR8D
	RET

	.PAGE


;*        SUBROUTINE IDEWAITNOTBUSY
;
;  WAIT FOR DRIVE NOT BUSY
;
;         ENTRY -
;
;         EXIT -
;                 CARRY FLAG SET ON ERROR.
;
;  ??  IT'S TOTALLY UNCLEAR HOW LONG THIS FUNCTION WAITS FOR THE CORRECT STATUS,
;  ??  NOR HOW THAT PERIOD MATCHES UP WITH WHAT THE IDE SPEC REQUIRES.  FOR THAT
;  ??  MATTER, ONCE BUSY IS CLEAR, DO WE REALLY NEED TO WAIT FOR RDY, OR SHOULD
;  ??  WE LOOK AT IT ONCE AND BE DONE?
;  ??  ALSO, SHOULD WE BE DELAYING A SHORT WHILE BEFORE READING THE STATUS REGISTER
;  ??  THE FIRST TIME, TO GIVE THE DRIVE A CHANCE TO SET BUSY?  NOTE THAT THIS IS
;  ??  CALLED BY E.G. THE READ DATA TRANSFER LOOP, WHERE SUCH A DELAY IS UNNEEDED AND
;  ??  COUNTER-PRODUCTIVE.
IDEWAITNOTBUSY			;IE DRIVE READY IF 01000000
	LD	B,0FFH
	LD	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
	LD	(DLYCNT),A

$10
	LD	E,REGSTATUS	;WAIT FOR RDY BIT TO BE SET
	CALL	IDERD8D
	LD	A,D
	AND	0C0H
	XOR	040H
	JR	Z,$20

	DEC	B
	JR	NZ,$10

	PROGRESS	"1"
	LD	A,(DLYCNT)	;CHECK TIMEOUT DELAY
	DEC	A
	LD	(DLYCNT),A
	JR	NZ,$10

	SCF			;SET CARRY TO INDICQATE AN ERROR
	RET

$20
	AND	A		;CLEAR CARRY TO INDICATE NO ERROR
	RET

	.PAGE

;*        SUBROUTINE IDEWAITDRQ
;
;  WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
;
;         ENTRY -
;
;         EXIT -
;
				;RETURNS THE DRIVE'S STATUS IN ACC
IDEWAITDRQ
	LD	B,0FFH
	LD	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
	LD	(DLYCNT),A

$10
	LD	E,REGSTATUS	;WAIT FOR DRQ BIT TO BE SET
	CALL	IDERD8D
	LD	A,D
	AND	088H
	CP	008H
	JR	Z,$20

	DEC	B
	JR	NZ,$10

	PROGRESS	"2"
	LD	A,(DLYCNT)	;CHECK TIMEOUT DELAY
	DEC	A
	LD	(DLYCNT),A
	JR	NZ,$10

	SCF			;SET CARRY TO INDICATE ERROR
	RET

$20
	AND	A		; CLEAR CARRY FLAG
	RET


	.PAGE

;*        SUBROUTINE IDERD8D
;
;  READ 8 BITS FROM IDE REGISTER IN [E], RETURN INFO IN [D]
;
;         ENTRY -
;
;         EXIT -  D - BYTE FROM DRIVE
;                 A DESTROYED;  ALL OTHERS PRESERVED.
;
;  PRESERVES BC, HL.
; LOW LEVEL 8 BIT R/W TO THE DRIVE CONTROLLER.  THESE ARE THE ROUTINES THAT TALK
; DIRECTLY TO THE DRIVE CONTROLLER REGISTERS, VIA THE 8255 CHIP.
; NOTE THE 16 BIT I/O TO THE DRIVE (WHICH IS ONLY FOR SEC R/W) IS DONE DIRECTLY
; IN THE ROUTINES READSECTOR & WRITESECTOR FOR SPEED REASONS.
;
IDERD8D
	LD	A,E
	OUT	(IDEPTC),A		;DRIVE ADDRESS ONTO CONTROL LINES

	OR	IDERDLINE		;RD PULSE PIN (40H)
	OUT	(IDEPTC),A		;ASSERT READ PIN

	IN	A,(IDEPTA)
	LD	D,A			;RETURN WITH DATA IN [D]

	LD	A,E			;<---KEN ROBBINS SUGGESTION
	OUT	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A
	OUT	(IDEPTC),A		;ZERO ALL PORT C LINES
	RET

	.PAGE

;*        SUBROUTINE IDEWR8D
;
;  WRITE DATA IN [D] TO IDE REGISTER IN [E]
;
;         ENTRY -
;
;         EXIT -
;
IDEWR8D
	LD	A,WRITECFG8255		;SET 8255 TO WRITE MODE
	OUT	(IDEPTCTRL),A

	LD	A,D			;GET DATA PUT IT IN 8255 A PORT
	OUT	(IDEPTA),A

	LD	A,E			;SELECT IDE REGISTER
	OUT	(IDEPTC),A

	OR	IDEWRLINE		;LOWER WR LINE
	OUT	(IDEPTC),A

	LD 	A,E			;<-- KEN ROBBINS SUGGESTION, RAISE WR LINE
	OUT 	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A			;DESELECT ALL LINES INCLUDING WR LINE
	OUT	(IDEPTC),A

	LD	A,READCFG8255		;CONFIG 8255 CHIP, READ MODE ON RETURN
	OUT	(IDEPTCTRL),A
	RET

;;    DELAY A LONG TIME
;
;  DELAY IS VERY ROUGHLY A * 1 MINUTE.

DELAYX	LD	(DLYCNT),A
	PUSH	BC
	LD	BC,0FFFFH	;<<< MAY NEED TO ADJUST DELAY TIME TO ALLOW COLD DRIVE TO
$2	LD	A,(DLYCNT)	;    GET UP TO SPEED.
$1	DEC	A
	JR	NZ,$1

	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,$2

	POP	BC
	RET

;    	DELAY32 - DELAY APPROXIMATELY 32 MS.
;
DELAY32 LD	A,40H		;DELAY ~32 MS (DOES NOT SEEM TO BE CRITICAL)
DELAY3	LD	B,0
$1	DJNZ	$1
	DEC	A
	JR	NZ,DELAY3

	RET
	.PAGE

;*        SUBROUTINE SHOWERRORS
;
;  DISPLAY THE CONTENTS OF THE DRIVE'S STATUS AND ERROR
;  REGISTERS.
;
;  THIS FUNCTION IS FREQUENTLY ENTERED VIA A JUMP RATHER
;  THAN A CALL.  THUS, WHEN IT RETURNS, IT RETURNS TO
;  THE CALLER OF THE PREVIOUS FUNCTION.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CLOBBERED
;		 CARRY FLAG SET
;
SHOWERRORS
   	LD	HL,STATMSG	; "STATUS = "
   	CALL	TXTOUT

	LD	E,REGSTATUS	;GET STATUS IN D REGISTER
	CALL	IDERD8D

	LD	A,D		; DISPLAY STATUS
	CALL	HEXOUT

   	LD	HL,ERRMSG	; "ERR = "
   	CALL	TXTOUT

	LD	E,REGERR	;GET STATUS IN D REGISTER
	CALL	IDERD8D

	LD	A,D		; DISPLAY STATUS
	CALL	HEXOUT

	LD	HL,CRLF
   	CALL	TXTOUT

	SCF			;SET CARRY FLAG
	RET

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

SHOWPROG
	CALL	OUTPUTCH
	LD	A,CH_CR
	CALL	OUTPUTCH
	LD	A,CH_LF
	CALL	OUTPUTCH
	RET


;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET

        .PAGE
;       KEYBOARD TRANSLATION TABLE
;
;  THIS TABLE IS ASSEMBLED WITH THE DISK FIRMWARE SO THAT IT RESIDES
;  IN THE PROM IN MAIN PROCESSOR MEMORY.  IT IS REFERENCED BY MONITOR.
;
        .INCLUDE        KEY_TBL.TEXT

        ASSUME  *,LE,PROMORG+PROMSIXE

        .END
