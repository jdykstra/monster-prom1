	.IF	IDE_TEST
        DEF_CH                  DEFINE CHARACTER SYMBOLS
	.ENDC



;**    VERSION   B2
VERSION  .EQU	"B2"


;**     CHANGE HISTORY
;
;

        .PAGE
;       HARDWARE DEFINITIONS
;
;  I/O PORTS
IDEPTA		.EQU    30H	;LOWER 8 BITS OF IDE INTERFACE (8255)
IDEPTB		.EQU    31H	;UPPER 8 BITS OF IDE INTERFACE
IDEPTC		.EQU    32H	;CONTROL LINES FOR IDE INTERFACE
IDEPTCTRL	.EQU    33H	;8255 CONFIGURATION PORT
IDEDRIVE        .EQU    34H	;BIT 0 = 0 DRIVE A, =1 DRIVE B

;  8255 CONTROL REGISTER VALUES
READCFG8255     .EQU    92H    ;SET 8255 IDEPTC TO OUTPUT, IDEPTA/B INPUT
WRITECFG8255    .EQU    80H    ;SET ALL THREE 8255 PORTS TO OUTPUT MODE

;  IDE CONTROL LINES FOR USE WITH IDEPTC.
IDEA0LINE       .EQU    01H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA1LINE       .EQU    02H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA2LINE       .EQU    04H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDECS0LINE      .EQU    08H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDECS1LINE      .EQU    10H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDEWRLINE       .EQU    20H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERDLINE       .EQU    40H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERSTLINE      .EQU    80H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE


;  SYMBOLIC CONSTANTS FOR THE IDE DRIVE REGISTERS, WHICH MAKES THE
;  CODE MORE READABLE THAN ALWAYS SPECIFYING THE ADDRESS BITS
REGDATA         .EQU    IDECS0LINE
REGERR          .EQU    IDECS0LINE + IDEA0LINE
REGSECCNT       .EQU    IDECS0LINE + IDEA1LINE
REGSECTOR       .EQU    IDECS0LINE + IDEA1LINE + IDEA0LINE
REGCYLLSB	.EQU    IDECS0LINE + IDEA2LINE
REGCYLMSB	.EQU    IDECS0LINE + IDEA2LINE + IDEA0LINE
REGSHD          .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE              ;(0EH)
REGCOMMAND      .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE  ;(0FH)
REGSTATUS       .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
REGCONTROL      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE
REGASTATUS      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE


;  IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
CMDRECAL	.EQU    10H
CMDREAD		.EQU    20H
CMDWRITE	.EQU    30H
CMDINIT		.EQU    91H
CMDID		.EQU    0ECH
CMDSPINDOWN 	.EQU    0E0H
CMDSPINUP	.EQU    0E1H

CMDFLUSH	.EQU	0EAH			; FLUSH CACHE


; IDE STATUS REGISTER:
;  BIT 7: BUSY	1=BUSY, 0=NOT BUSY
;  BIT 6: READY 1=READY FOR COMMAND, 0=NOT READY YET
;  BIT 5: DF	1=FAULT OCCURED INSIDE DRIVE
;  BIT 4: DSC	1=SEEK COMPLETE
;  BIT 3: DRQ	1=DATA REQUEST READY, 0=NOT READY TO XFER YET
;  BIT 2: CORR	1=CORRECTABLE ERROR OCCURED
;  BIT 1: IDX	VENDOR SPECIFIC
;  BIT 0: ERR	1=ERROR OCCURED

	.PAGE
	.IF	IDE_TEST
	.MACRO PROGRESS
	LD	A,%1
	CALL	SHOWPROG
	.ENDM
	.ELSE
	.MACRO PROGRESS
	.ENDM
	.ENDC

        .PAGE
;*        ENTRY DISPATCH TABLE
;
        .ORG	IDE_TBL
	JP	IDEREAD1	; READ ENTRY POINT
	JP	IDEWRT1		; WRITE ENTRY POINT
	JP	IDEINIT1	; INITIALIZATION ENTRY POINT
	.IF	IDE_TEST
	JP	TEST		; TEST ENTRY POINT
	.ENDC

	.IF	IDE_TEST

BUFFER	.EQU	07020H

TEST	EI			; MAKE SURE INTERRUPTS ARE ENABLED

	LD	HL,HELLOMSG	; ANNOUNCE WE GOT THIS FAR
	CALL	TXTOUT

	LD	HL,DRQBLK1	; WRITE OUT THE START OF PROM 1
	LD	A,M_DSKWRT	; WRITE MONITOR REQUEST
	MTRREQ
	AND	A		; TEST FOR ERRORS
	JR	NZ,$20

	LD	HL,WRTMSG	; "ONE SECTOR WRITTEN"
	CALL	TXTOUT

	LD	HL,DRQBLK2	; READ INTO RAM
	LD	A,M_DSKRD	; READ MONITOR REQUEST
	MTRREQ
	AND	A		; TEST FOR ERRORS
	JR	NZ,$20

	CALL	SHOWERRORS

	LD	HL,RDMSG	; "READ DATA ="
	CALL	TXTOUT
	LD	A,(BUFFER)
	CALL	HEXOUT
	LD	HL,CMPMSG	; "TEST COMPLETED."
	CALL	TXTOUT

$1	JP 	$1

$20	LD	HL,ABTMSG	; "TEST ABORTED"
	CALL	TXTOUT
	LD	A,M_KBCHAR	; WAIT FOR USER
	MTRREQ
	JR	$1
	.PAGE

;*	   CONSTANTS USED ONLY IN REQUEST BLOCKS
;
FMTIDE	.EQU	0		; FORMAT CODE FOR IDE DRIVES


;* 	   REQUEST BLOCKS
;
	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK1 .BYTE	2+000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.WORD	0		; BLOCK #
	.BLOCK	1		; UNUSED BY IDE
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	2		; UNUSED
	.WORD	PROM1ORG	; MEMORY ADDRESS
	.BLOCK	1		; UNUSED

	.ALIGN	2		; PUT BLOCK ON WORD BOUNDARY
DRQBLK2 .BYTE	2+000H		; PHYISICAL UNIT NUMBER + LOGICAL DISK #
	.WORD	0		; BLOCK #
	.BLOCK	1		; UNUSED BY IDE
	.BYTE	FMTIDE		; DISK FORMAT CODE
	.BYTE	0		; FLAGS BYTE
	.BLOCK	2		; UNUSED
	.WORD	BUFFER		; MEMORY ADDRESS
	.BLOCK	1		; UNUSED


;*        CONSOLE MESSAGES
;
;
HELLOMSG .ASCII "IDE DRIVER TEST "
        .BYTE   VERSION/100H
        .BYTE   VERSION&0FFH
        .BYTE	CH_CR
        .BYTE	CH_LF
        .BYTE	CH_ETX

INITMSG	.ASCII	"INITIALIZING IDE DRIVER."
	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX

STATMSG	.ASCII	"STATUS = "
	.BYTE	CH_ETX

ERRMSG	.ASCII	", ERR = "
	.BYTE	CH_ETX

WRTMSG	.ASCII	"ONE SECTOR WRITTEN."
	.BYTE	CH_ETX

ABTMSG	.ASCII	"TEST ABORTED."
	.BYTE	CH_ETX

RDMSG	.ASCII	"READ DATA = "
	.BYTE	CH_ETX

CMPMSG	.BYTE	CH_CR
	.BYTE	CH_LF
	.ASCII	"TEST COMPLETED."
	.BYTE	CH_ETX

CRLF	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX
	.ENDC

;*        WORK AREA
;
;
DLYCNT	.EQU	IDEWORK
	.PAGE

;*        SUBROUTINE IDEINIT
;
;  INITIALIZE 8255 PIO CHIP AND DRIVE,  AND THEN CHECK DRIVE STATUS.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CHANGED
;
IDEINIT1
	.IF	IDE_TEST
	LD	HL,INITMSG	; "INITIALIZING IDE DRIVER."
	CALL	TXTOUT
	.ENDC

	LD	A,READCFG8255	;CONFIG 8255 CHIP (10010010B), READ MODE ON RETURN
	OUT	(IDEPTCTRL),A	;CONFIG 8255 CHIP, READ MODE

				;HARD RESET THE DISK DRIVE
				;FOR SOME REASON SOME CF CARDS NEED TO THE RESET LINE
				;PULSED VERY CAREFULLY. YOU MAY NEED TO PLAY AROUND
	LD	A,IDERSTLINE	;WITH THE PULSE LENGTH. SYMPTOMS ARE: INCORRECT DATA COMMING
	OUT	(IDEPTC),A	;BACK FROM A SECTOR READ (OFTEN DUE TO THE WRONG SECTOR BEING READ)
				;I HAVE A (NEGATIVE)PULSE OF 2.7USEC. (10MZ Z80, TWO IO WAIT STATES).
	LD	B,40H		;WHICH SEEM TO WORK FOR THE 5 DIFFERENT CF CARDS I HAVE.
$1	DEC	B		; JWD - SPEC SAYS 25 USEC MINIMUM!!!
	JR	NZ,$1		;DELAY (RESET PULSE WIDTH)

	XOR	A
	OUT	(IDEPTC),A	;NO IDE CONTROL LINES ASSERTED (JUST BIT 7 OF PORT C)
	CALL	DELAY32

	LD	D,11100000B	;DATA FOR IDE SDH REG (512BYTES, LBA MODE,SINGLE DRIVE,HEAD 0000)
				;FOR TRK,SEC,HEAD (NON LBA) USE 10100000
	LD	E,REGSHD	;00001110,(0EH) FOR CS0,A2,A1,
	CALL	IDEWR8D		;WRITE BYTE TO SELECT THE MASTER DEVICE
;
;  WAIT FOR DRIVE NOT BUSY, AND THE READY BIT SET.
;  THE BOARD DESIGNER'S CODE HAD AN EXTRA-LONG WAIT TIME HERE, TO HANDLE HDS SPINNING UP.
;  WE DON'T WORRY ABOUT THAT, TO SAVE CODE SPACE.
;
	CALL	IDEWAITNOTBUSY	; WAIT FOR DRIVE NOT BUSY (AND READY)
	RET	NC

	JP	SHOWERRORS	; REPORT AN ERROR



	.PAGE

;*        SUBROUTINE IDEREAD1
;
;  READ A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA
;  ENTERED FROM THE FLOPPY DISK DRIVER, DRV_DSK.TEXT.
;
;         ENTRY - REQUEST BLOCK POINTER IN IY
;
;         EXIT -  A CONTAINS ERROR CODE, OR ZERO IF NONE.
;
				;Z ON SUCCESS, NZ CALL ERROR ROUTINE IF PROBLEM
IDEREAD1
	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE
				;WILL GET STUCK ON BAD SECTOR
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS READY
	JR	C,GOSHOWERRORS	;RETURNED WITH NZ SET IF ERROR

	LD	D,CMDREAD	; ISSUE IDE READ COMMAND
	LD	E,REGCOMMAND
	CALL	IDEWR8D		;SEND SEC READ COMMAND TO DRIVE.

	CALL	IDEWAITDRQ	;WAIT UNTIL DRIVE READY TO DELIVER DATA
	JR	C,GOSHOWERRORS

	LD  	L,(IY+C_DRQADL);BUFFER ADDRESS
	LD  	H,(IY+C_DRQADH)
	LD	B,0		;READ 512 BYTES TO [HL] (256X2 BYTES)

$1	LD	A,REGDATA	;DATA REGISTER ADDRESS, NO READ LINE
	OUT	(IDEPTC),A

	OR	IDERDLINE	;08H+40H, ASSERT RD LINE
	OUT	(IDEPTC),A

	IN	A,(IDEPTA)	;READ THE LOWER BYTE FIRST
	LD	(HL),A
	INC	HL
	IN	A,(IDEPTB)	;THEN READ THE UPPER BYTE
	LD	(HL),A
	INC	HL

	DJNZ	$1

	LD	A,REGDATA	;DEASSERT RD LINE
	OUT	(IDEPTC),A

	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOSHOWERRORS

	LD	E,REGSTATUS
	CALL	IDERD8D
	LD	A,D
	AND	1H
	CALL	NZ,SHOWERRORS	;IF ERROR DISPLAY STATUS

	CALL	IDEADVBLK	; ADVANCE THE BLOCK NUMBER
	RET

GOSHOWERRORS
	JP	SHOWERRORS
	.PAGE

;*        SUBROUTINE IDEWRITE1
;
;  WRITE A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA.
;  ENTERED FROM THE FLOPPY DISK DRIVER, DRV_DSK.TEXT.
;
;         ENTRY - REQUEST BLOCK POINTER IN IY
;
;         EXIT -  A CONTAINS ERROR CODE, OR ZERO IF NONE.
;
IDEWRT1
;	PROGRESS	"A"
	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE
				;WILL GET STUCK ON BAD SECTOR
	PROGRESS	"B"
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOSHOWERRORS

	PROGRESS	"C"
	LD	D,CMDWRITE
	LD	E,REGCOMMAND
	CALL	IDEWR8D		;TELL DRIVE TO WRITE A SECTOR

	PROGRESS	"D"
	CALL	IDEWAITDRQ	;WAIT UNIT IT WANTS THE DATA
	JR	C,GOSHOWERRORS

	PROGRESS	"E"
	LD  	L,(IY+C_DRQADL);BUFFER ADDRESS
	LD  	H,(IY+C_DRQADH)
	LD	B,0		;256X2 BYTES

	LD	A,WRITECFG8255
	OUT	(IDEPTCTRL),A

$10	LD	A,(HL)
	INC	HL
	OUT	(IDEPTA),A	;WRITE THE LOWER BYTE FIRST
	LD	A,(HL)
	INC	HL
	OUT	(IDEPTB),A	;THEN HIGH BYTE ON B
	LD	A,REGDATA
	PUSH	AF
	OUT	(IDEPTC),A	;SEND WRITE COMMAND
	OR	IDEWRLINE	;SEND WR PULSE
	OUT	(IDEPTC),A
	POP	AF
	OUT	(IDEPTC),A
	DJNZ	$10

	PROGRESS	"F"
	LD	A,READCFG8255	;SET 8255 BACK TO READ MODE
	OUT	(IDEPTCTRL),A

	PROGRESS	"G"
	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS NOT BUSY
	JR	C,GOBSHOWERRORS

	LD	E,REGSTATUS
	CALL	IDERD8D
	LD	A,D
	AND	1H
	CALL	NZ,SHOWERRORS	;IF ERROR DISPLAY STATUS

	CALL	IDEADVBLK	; ADVANCE THE BLOCK NUMBER
	RET

GOBSHOWERRORS
	JP	SHOWERRORS
	.PAGE
;*        SUBROUTINE WRLBA
;
;  WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
;
;         ENTRY - REQUEST BLOCK POINTER IN IY
;
;         EXIT -
;
WRLBA
				;NOTE WE DO NOT NEED TO SET THE UPPER NIBBLE OF THE LBA
				;IT WILL ALWAYS BE 0 FOR THESE SMALL DRIVES
	LD	D,(IY+C_DRQTRK)		;LBA MODE LOW SECTORS GO DIRECTLY
	LD	E,REGSECTOR	;SEND INFO TO DRIVE
	CALL	IDEWR8D

	LD	D,(IY+C_DRQTRK+1) ; LOW TRACK NUMBER
	LD	E,REGCYLLSB
	CALL	IDEWR8D

	LD	D,0		;SEND HIGH TRK#
	LD	E,REGCYLMSB
	CALL	IDEWR8D

	LD	D,1		;FOR NOW, ONE SECTOR AT A TIME
	LD	E,REGSECCNT
	CALL	IDEWR8D
	RET

	.PAGE


;*        SUBROUTINE IDEWAITNOTBUSY
;
;  WAIT FOR DRIVE NOT BUSY
;
;         ENTRY -
;
;         EXIT -
;                 CARRY FLAG SET ON ERROR.
;
;  ??  IT'S TOTALLY UNCLEAR HOW LONG THIS FUNCTION WAITS FOR THE CORRECT STATUS,
;  ??  NOR HOW THAT PERIOD MATCHES UP WITH WHAT THE IDE SPEC REQUIRES.  FOR THAT
;  ??  MATTER, ONCE BUSY IS CLEAR, DO WE REALLY NEED TO WAIT FOR RDY, OR SHOULD
;  ??  WE LOOK AT IT ONCE AND BE DONE?
;  ??  ALSO, SHOULD WE BE DELAYING A SHORT WHILE BEFORE READING THE STATUS REGISTER
;  ??  THE FIRST TIME, TO GIVE THE DRIVE A CHANCE TO SET BUSY?  NOTE THAT THIS IS
;  ??  CALLED BY E.G. THE READ DATA TRANSFER LOOP, WHERE SUCH A DELAY IS UNNEEDED AND
;  ??  COUNTER-PRODUCTIVE.
IDEWAITNOTBUSY			;IE DRIVE READY IF 01000000
	LD	B,0FFH
	LD	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
	LD	(DLYCNT),A

$10
	LD	E,REGSTATUS	;WAIT FOR RDY BIT TO BE SET
	CALL	IDERD8D
	LD	A,D
	AND	0C0H
	XOR	040H
	JR	Z,$20

	DEC	B
	JR	NZ,$10

	PROGRESS	"1"
	LD	A,(DLYCNT)	;CHECK TIMEOUT DELAY
	DEC	A
	LD	(DLYCNT),A
	JR	NZ,$10

	SCF			;SET CARRY TO INDICQATE AN ERROR
	RET

$20
	AND	A		;CLEAR CARRY TO INDICATE NO ERROR
	RET

	.PAGE

;*        SUBROUTINE IDEWAITDRQ
;
;  WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
;
;         ENTRY -
;
;         EXIT -
;
				;RETURNS THE DRIVE'S STATUS IN ACC
IDEWAITDRQ
	LD	B,0FFH
	LD	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
	LD	(DLYCNT),A

$10
	LD	E,REGSTATUS	;WAIT FOR DRQ BIT TO BE SET
	CALL	IDERD8D
	LD	A,D
	AND	088H
	CP	008H
	JR	Z,$20

	DEC	B
	JR	NZ,$10

	PROGRESS	"2"
	LD	A,(DLYCNT)	;CHECK TIMEOUT DELAY
	DEC	A
	LD	(DLYCNT),A
	JR	NZ,$10

	SCF			;SET CARRY TO INDICATE ERROR
	RET

$20
	AND	A		; CLEAR CARRY FLAG
	RET


	.PAGE

;*        SUBROUTINE IDERD8D
;
;  READ 8 BITS FROM IDE REGISTER IN [E], RETURN INFO IN [D]
;
;         ENTRY -
;
;         EXIT -  D - BYTE FROM DRIVE
;                 A DESTROYED;  ALL OTHERS PRESERVED.
;
;  PRESERVES BC, HL.
; LOW LEVEL 8 BIT R/W TO THE DRIVE CONTROLLER.  THESE ARE THE ROUTINES THAT TALK
; DIRECTLY TO THE DRIVE CONTROLLER REGISTERS, VIA THE 8255 CHIP.
; NOTE THE 16 BIT I/O TO THE DRIVE (WHICH IS ONLY FOR SEC R/W) IS DONE DIRECTLY
; IN THE ROUTINES READSECTOR & WRITESECTOR FOR SPEED REASONS.
;
IDERD8D
	LD	A,E
	OUT	(IDEPTC),A		;DRIVE ADDRESS ONTO CONTROL LINES

	OR	IDERDLINE		;RD PULSE PIN (40H)
	OUT	(IDEPTC),A		;ASSERT READ PIN

	IN	A,(IDEPTA)
	LD	D,A			;RETURN WITH DATA IN [D]

	LD	A,E			;<---KEN ROBBINS SUGGESTION
	OUT	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A
	OUT	(IDEPTC),A		;ZERO ALL PORT C LINES
	RET

	.PAGE

;*        SUBROUTINE IDEWR8D
;
;  WRITE DATA IN [D] TO IDE REGISTER IN [E]
;
;         ENTRY -
;
;         EXIT -
;
IDEWR8D
	LD	A,WRITECFG8255		;SET 8255 TO WRITE MODE
	OUT	(IDEPTCTRL),A

	LD	A,D			;GET DATA PUT IT IN 8255 A PORT
	OUT	(IDEPTA),A

	LD	A,E			;SELECT IDE REGISTER
	OUT	(IDEPTC),A

	OR	IDEWRLINE		;LOWER WR LINE
	OUT	(IDEPTC),A

	LD 	A,E			;<-- KEN ROBBINS SUGGESTION, RAISE WR LINE
	OUT 	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A			;DESELECT ALL LINES INCLUDING WR LINE
	OUT	(IDEPTC),A

	LD	A,READCFG8255		;CONFIG 8255 CHIP, READ MODE ON RETURN
	OUT	(IDEPTCTRL),A
	RET

;;    DELAY A LONG TIME
;
;  DELAY IS VERY ROUGHLY A * 1 MINUTE.

DELAYX	LD	(DLYCNT),A
	PUSH	BC
	LD	BC,0FFFFH	;<<< MAY NEED TO ADJUST DELAY TIME TO ALLOW COLD DRIVE TO
$2	LD	A,(DLYCNT)	;    GET UP TO SPEED.
$1	DEC	A
	JR	NZ,$1

	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,$2

	POP	BC
	RET

;    	DELAY32 - DELAY APPROXIMATELY 32 MS.
;
DELAY32 LD	A,40H		;DELAY ~32 MS (DOES NOT SEEM TO BE CRITICAL)
DELAY3	LD	B,0
$1	DJNZ	$1
	DEC	A
	JR	NZ,DELAY3

	RET
	.PAGE

;*	  SUBROUTINE IDEADVBLK
;
;  ADVANCE THE BLOCK NUMBER IN THE REQUEST BLOCK.
;
;         ENTRY - REQUEST BLOCK POINTER IN IY.
;
;	  EXIT - A REGISTER ZERO
;
IDEADVBLK  LD	L,(IY+C_DRQTRK)	; INCREMENT BLOCK NUMBER
	LD	H,(IY+C_DRQTRK+1)
	INC	HL
	LD	(IY+C_DRQTRK),L
	LD	(IY+C_DRQTRK+1),H

	XOR	A		; CLEAR A
	RET
	.PAGE

;*        SUBROUTINE SHOWERRORS
;
;  DISPLAY THE CONTENTS OF THE DRIVE'S STATUS AND ERROR
;  REGISTERS.
;
;  THIS FUNCTION IS FREQUENTLY ENTERED VIA A JUMP RATHER
;  THAN A CALL.  THUS, WHEN IT RETURNS, IT RETURNS TO
;  THE CALLER OF THE PREVIOUS FUNCTION.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CLOBBERED
;		 ERROR CODE IN A
;
SHOWERRORS
	.IF	IDE_TEST
   	LD	HL,STATMSG	; "STATUS = "
   	CALL	TXTOUT

	LD	E,REGSTATUS	;GET STATUS IN D REGISTER
	CALL	IDERD8D

	LD	A,D		; DISPLAY STATUS
	CALL	HEXOUT

   	LD	HL,ERRMSG	; "ERR = "
   	CALL	TXTOUT

	LD	E,REGERR	;GET STATUS IN D REGISTER
	CALL	IDERD8D

	LD	A,D		; DISPLAY STATUS
	CALL	HEXOUT

	LD	HL,CRLF
   	CALL	TXTOUT
	.ENDC

	LD	A,1		; SET NON-ZERO (??  NEED BETTER ERROR CODES)
	RET

	.PAGE
;*        SUBROUTINE SHOWPROG - DISPLAY A PROGRESS INDICATOR
;
;  OUTPUT A SINGLE CHARACTER, FOLLOWED BY <CR><LF>.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;
	.IF	IDE_TEST
SHOWPROG
	CALL	OUTPUTCH
	LD	A,CH_CR
	CALL	OUTPUTCH
	LD	A,CH_LF
	CALL	OUTPUTCH
	RET


;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET
        .ENDC

