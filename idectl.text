        .ABSOLUTE
        .PROC   IDECTL


LISTINC .EQU    0
        .INCLUDE ASMINC.TEXT
;;;        .INCLUDE DUTEXT.TEXT

;;;        DEF_MPU                 ; DEFINE MPU SYMBOLS
        DEF_CH                  DEFINE CHARACTER SYMBOLS



;**    VERSION   A1
VERSION  .EQU	"A1"


;**     CHANGE HISTORY
;
;

        .PAGE
;*        ASSEMBLY PARAMETERS AND CONFIGURATION INFO
;
;
FALSE   .EQU    0
TRUE    .EQU    ~FALSE

DEBUG	.EQU	TRUE

PROMORG	.EQU	0800H		; OUR ORIGIN (PROM SOCKET 1)
PROMSIZE .EQU	0800H		; SIZE OF PROM WE NEED TO FIT IN
KEY_TBL .EQU    0C00H     	; WHERE MONITOR EXPECTS KEYBOARD TABLE


;       HARDWARE DEFINITIONS
;
;  I/O PORTS
IDEPTA		.EQU    30H	;LOWER 8 BITS OF IDE INTERFACE (8255)
IDEPTB		.EQU    31H	;UPPER 8 BITS OF IDE INTERFACE
IDEPTC		.EQU    32H	;CONTROL LINES FOR IDE INTERFACE
IDEPTCTRL	.EQU    33H	;8255 CONFIGURATION PORT
IDEDRIVE        .EQU    34H	;BIT 0 = 0 DRIVE A, =1 DRIVE B

;  8255 CONTROL REGISTER VALUES
READCFG8255     .EQU    92H    ;SET 8255 IDEPTC TO OUTPUT, IDEPTA/B INPUT
WRITECFG8255    .EQU    80H    ;SET ALL THREE 8255 PORTS TO OUTPUT MODE

;  IDE CONTROL LINES FOR USE WITH IDEPTC.
IDEA0LINE       .EQU    01H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA1LINE       .EQU    02H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDEA2LINE       .EQU    04H     ;DIRECT FROM 8255 TO IDE INTERFACE
IDECS0LINE      .EQU    08H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDECS1LINE      .EQU    10H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDEWRLINE       .EQU    20H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERDLINE       .EQU    40H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE
IDERSTLINE      .EQU    80H     ;INVERTER BETWEEN 8255 AND IDE INTERFACE


;  SYMBOLIC CONSTANTS FOR THE IDE DRIVE REGISTERS, WHICH MAKES THE
;  CODE MORE READABLE THAN ALWAYS SPECIFYING THE ADDRESS BITS
REGDATA         .EQU    IDECS0LINE
REGERR          .EQU    IDECS0LINE + IDEA0LINE
REGSECCNT       .EQU    IDECS0LINE + IDEA1LINE
REGSECTOR       .EQU    IDECS0LINE + IDEA1LINE + IDEA0LINE
REGCYLLSB	.EQU    IDECS0LINE + IDEA2LINE
REGCYLMSB	.EQU    IDECS0LINE + IDEA2LINE + IDEA0LINE
REGSHD          .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE              ;(0EH)
REGCOMMAND      .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE  ;(0FH)
REGSTATUS       .EQU    IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
REGCONTROL      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE
REGASTATUS      .EQU    IDECS1LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE


;  IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
CMDRECAL	.EQU    10H
CMDREAD		.EQU    20H
CMDWRITE	.EQU    30H
CMDINIT		.EQU    91H
CMDID		.EQU    0ECH
CMDSPINDOWN 	.EQU    0E0H
CMDSPINUP	.EQU    0E1H


; IDE STATUS REGISTER:
;  BIT 7: BUSY	1=BUSY, 0=NOT BUSY
;  BIT 6: READY 1=READY FOR COMMAND, 0=NOT READY YET
;  BIT 5: DF	1=FAULT OCCURED INSIDE DRIVE
;  BIT 4: DSC	1=SEEK COMPLETE
;  BIT 3: DRQ	1=DATA REQUEST READY, 0=NOT READY TO XFER YET
;  BIT 2: CORR	1=CORRECTABLE ERROR OCCURED
;  BIT 1: IDX	VENDOR SPECIFIC
;  BIT 0: ERR	1=ERROR OCCURED

	.PAGE

	.ORG	PROMORG
ENTRY
	LD	HL,HELLOMSG	; ANNOUNCE WE GOT THIS FAR
	CALL	TXTOUT

	CALL	IDEINIT		; INITIALIZE DRIVE

	LD	HL,INITMSG	; "DRIVE INITIALIZED."
	CALL	TXTOUT

$1	JP 	$1
	.PAGE

;*        CONSOLE MESSAGES
;
;
HELLOMSG .ASCII "IDE DRIVER TEST "
        .BYTE   VERSION/100H
        .BYTE   VERSION&0FFH
        .BYTE	CH_CR
        .BYTE	CH_LF
        .BYTE	CH_ETX

INITMSG	.ASCII	"DRIVE INITIALIZED."
	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX

STATMSG	.ASCII	"DRIVE STATUS = "
	.BYTE	CH_ETX

CRLF	.BYTE	CH_CR
	.BYTE	CH_LF
	.BYTE	CH_ETX

;*        PROGRAM VARIABLES
;
;
DELAYSTORE .BLOCK  1               ; SCRATCH FOR DELAY SUBROUTINE

	.PAGE

;*        SUBROUTINE IDEINIT
;
;  INITIALIZE 8255 AND DRIVE,  AND THEN CHECK DRIVE STATUS.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CHANGED
;
IDEINIT				;INITITALIZE THE 8255 AND DRIVE THEN DO A HARD RESET ON THE DRIVE,
	LD	A,READCFG8255	;CONFIG 8255 CHIP (10010010B), READ MODE ON RETURN
	OUT	(IDEPTCTRL),A	;CONFIG 8255 CHIP, READ MODE

				;HARD RESET THE DISK DRIVE
				;FOR SOME REASON SOME CF CARDS NEED TO THE RESET LINE
				;PULSED VERY CAREFULLY. YOU MAY NEED TO PLAY AROUND
	LD	A,IDERSTLINE	;WITH THE PULSE LENGTH. SYMPTOMS ARE: INCORRECT DATA COMMING
	OUT	(IDEPTC),A	;BACK FROM A SECTOR READ (OFTEN DUE TO THE WRONG SECTOR BEING READ)
				;I HAVE A (NEGATIVE)PULSE OF 2.7USEC. (10MZ Z80, TWO IO WAIT STATES).
				; JWD - CUT DELAY IN HALF (10H INSTEAD OF 20H) FOR 4 MHZ Z80.
	LD	B,10H		;WHICH SEEM TO WORK FOR THE 5 DIFFERENT CF CARDS I HAVE.
$1	DEC	B
	JR	NZ,$1		;DELAY (RESET PULSE WIDTH)

	XOR	A
	OUT	(IDEPTC),A	;NO IDE CONTROL LINES ASSERTED (JUST BIT 7 OF PORT C)
	CALL	DELAY32

	LD	D,11100000B	;DATA FOR IDE SDH REG (512BYTES, LBA MODE,SINGLE DRIVE,HEAD 0000)
				;FOR TRK,SEC,HEAD (NON LBA) USE 10100000
				;NOTE. CANNOT GET LBA MODE TO WORK WITH AN OLD SEAGATE MEDALIST 6531 DRIVE.
				;HAVE TO USE TEH NON-LBA MODE. (COMMON FOR OLD HARD DISKS).

	LD	E,REGSHD	;00001110,(0EH) FOR CS0,A2,A1,
	CALL	IDEWR8D		;WRITE BYTE TO SELECT THE MASTER DEVICE

	LD	B,0FFH		;<<< MAY NEED TO ADJUST DELAY TIME FOR HARD DISKS
$2
	LD	E,REGSTATUS	;GET STATUS AFTER INITILIZATION
	CALL	IDERD8D		;CHECK STATUS (INFO IN [D])
	LD	A,D
	AND	80H
	JR	Z,$3		;RETURN IF READY BIT IS ZERO

	LD	A,2
	CALL	DELAYX		;LONG DELAY, DRIVE HAS TO GET UP TO SPEED
	DEC	B
	JR	NZ,$2

	CALL	SHOWERRORS	;RET WITH NZ FLAG SET IF ERROR (PROBABLY NO DRIVE)
	RET

$3
	XOR	A
	RET

;------------------------------------------------------------------
; LOW LEVEL 8 BIT R/W TO THE DRIVE CONTROLLER.  THESE ARE THE ROUTINES THAT TALK
; DIRECTLY TO THE DRIVE CONTROLLER REGISTERS, VIA THE 8255 CHIP.
; NOTE THE 16 BIT I/O TO THE DRIVE (WHICH IS ONLY FOR SEC R/W) IS DONE DIRECTLY
; IN THE ROUTINES READSECTOR & WRITESECTOR FOR SPEED REASONS.
;
IDERD8D					;READ 8 BITS FROM IDE REGISTER IN [E], RETURN INFO IN [D]
	LD	A,E
	OUT	(IDEPTC),A		;DRIVE ADDRESS ONTO CONTROL LINES

	OR	IDERDLINE		;RD PULSE PIN (40H)
	OUT	(IDEPTC),A		;ASSERT READ PIN

	IN	A,(IDEPTA)
	LD	D,A			;RETURN WITH DATA IN [D]

	LD	A,E			;<---KEN ROBBINS SUGGESTION
	OUT	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A
	OUT	(IDEPTC),A		;ZERO ALL PORT C LINES
	RET


IDEWR8D					;WRITE DATA IN [D] TO IDE REGISTER IN [E]
	LD	A,WRITECFG8255		;SET 8255 TO WRITE MODE
	OUT	(IDEPTCTRL),A

	LD	A,D			;GET DATA PUT IT IN 8255 A PORT
	OUT	(IDEPTA),A

	LD	A,E			;SELECT IDE REGISTER
	OUT	(IDEPTC),A

	OR	IDEWRLINE		;LOWER WR LINE
	OUT	(IDEPTC),A

	LD 	A,E			;<-- KEN ROBBINS SUGGESTION, RAISE WR LINE
	OUT 	(IDEPTC),A		;DEASSERT RD PIN

	XOR	A			;DESELECT ALL LINES INCLUDING WR LINE
	OUT	(IDEPTC),A

	LD	A,READCFG8255		;CONFIG 8255 CHIP, READ MODE ON RETURN
	OUT	(IDEPTCTRL),A
	RET

;;    DELAY A LONG TIME
;

DELAYX	LD	(DELAYSTORE),A
	PUSH	BC
	LD	BC,0FFFFH	;<<< MAY NEED TO ADJUST DELAY TIME TO ALLOW COLD DRIVE TO
$2	LD	A,(DELAYSTORE)	;    GET UP TO SPEED.
$1	DEC	A
	JR	NZ,$1

	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,$2

	POP	BC
	RET




;    	DELAY32 - DELAY APPROXIMATELY 32 MS.
;
DELAY32 LD	A,40H		;DELAY ~32 MS (DOES NOT SEEM TO BE CRITICAL)
DELAY3	LD	B,0
$1	DJNZ	$1
	DEC	A
	JR	NZ,DELAY3

	RET
	.PAGE

;*        SUBROUTINE SHOWERRORS
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - NOTHING
;
;         EXIT - ALL REGISTERS CLOBBERED
;
SHOWERRORS
   	LD	HL,STATMSG	; "DRIVE STATUS = "
   	CALL	TXTOUT

	LD	E,REGSTATUS	;GET STATUS IN D REGISTER
	CALL	IDERD8D

	LD	A,D		; DISPLAY STATUS
	CALL	HEXOUT

	LD	HL,CRLF
   	CALL	TXTOUT

	OR	A		;SET Z FLAG
	SCF			;SET CARRY FLAG
	RET

;*        SUBROUTINE HEXOUT - WRITE OUT ONE BYTE IN HEX
;
;  TRANSLATE THE PARAMETER BYTE INTO TWO HEXIDECIMAL
;  CHARACTERS, AND WRITE THEM TO THE USER.
;
;         ENTRY - PARAMETER IN A REGISTER.
;
;         EXIT - A REGISTER DESTROYED.
;                ALL OTHERS PRESERVED.
;

HEXOUT
        PUSH    AF              ; SAVE PARAMETER FOR LATER
        SRL     A               ; RIGHT-JUSTIFY TOP DIGIT
        SRL     A
        SRL     A
        SRL     A
        CP      10.             ; IS IT NUMERIC
        JR      C,HEXOUTA       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTA
        ADD     A,"0"           ; MAKE INTO  ASCII
        CALL    OUTPUTCH        ; WRITE TOP NIBBLE

        POP     AF              ; GET BACK NUMBER
        AND     0FH             ; SAVE LOW DIGIT
        CP      10.             ; IT IS NUMERIC
        JR      C,HEXOUTB       ; YES.  JUMP
        ADD     A,7             ; BOOST NUMBER
HEXOUTB
        ADD     A,"0"           ; MAKE INTO ASCII
        CALL    OUTPUTCH        ; WRITE OUT BOTTOM DIGIT

        RET     	        ; AND  RETURN TO CALLER
        .PAGE
;*        SUBROUTINE TXTOUT - WRITE TEXT BLOCK TO USER
;
;  TRANSFER A TEXT STRING TERMINATED BY AN ETX CHARACTER TO
;  THE USER.
;
;         ENTRY - ADDRESS OF FIRST CHARACTER OF STRING IN HL
;
;         EXIT - HL POINTS TO ETX CHARACTER.
;                A CONTAINS -CH.ETX-
;                ALL OTHER REGISTERS ARE PRESERVED.
;
TXTOUT
        LD      A,(HL)          ; GET NEXT CHARACTER IN TEXT
        CP      CH_ETX          ; IS IT END-OF-TEXT
        RET     Z               ; RETURN IF IT IS END-OF-TEXT

        CALL    OUTPUTCH        ; WRITE OUT CHARACTER
        INC     HL              ; BUMP TEXT POINTER
        JR      TXTOUT          ; AND LOOP FOR NEXT CHARACTER
        .PAGE
;*        SUBROUTINE OUTPUTCH
;
;  WRITE ONE CHARACTER FROM REGISTER A TO THE
;  DISPLAY.
;
;         ENTRY - CHARACTER IN A
;
;         EXIT - ALL REGISTERS PRESERVED
;
OUTPUTCH
        PUSH    IX              ; SAVE ALL USER REGISTERS
        PUSH    IY
        PUSH    HL
        PUSH    DE
        PUSH    BC
        PUSH    AF

        LD      C,A             ; MOVE CHARACTER TO C REGISTER
        MTRREQ  M_DSPCHR        ; DISPLAY CHARACTER

        POP     AF              ; RESTORE USER REGISTERS
        POP     BC
        POP     DE
        POP     HL
        POP     IY
        POP     IX

        RET

        .PAGE
;       KEYBOARD TRANSLATION TABLE
;
;  THIS TABLE IS ASSEMBLED WITH THE DISK FIRMWARE SO THAT IT RESIDES
;  IN THE PROM IN MAIN PROCESSOR MEMORY.  IT IS REFERENCED BY MONITOR.
;
        .INCLUDE        KEY_TBL.TEXT

        ASSUME  *,LE,PROMORG+PROMSIXE

        .END
